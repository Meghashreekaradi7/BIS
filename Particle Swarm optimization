import numpy as np

# Objective function
def objective_function(position):
    x, y = position
    return x**2 + y**2

# Particle Swarm Optimization (only 5 iterations)
def PSO(num_particles=30, max_iter=5, W=0.5, C1=1.5, C2=1.5):
    # Initialize positions and velocities
    particles = np.random.uniform(-10, 10, (num_particles, 2))
    velocities = np.random.uniform(-1, 1, (num_particles, 2))

    # Personal bests
    pbest_positions = particles.copy()
    pbest_values = np.array([objective_function(p) for p in particles])

    # Global best
    gbest_index = np.argmin(pbest_values)
    gbest_position = pbest_positions[gbest_index].copy()
    gbest_value = pbest_values[gbest_index]

    # Iterations
    for iteration in range(max_iter):
        for i in range(num_particles):
            # Evaluate fitness
            fitness = objective_function(particles[i])

            # Update personal best
            if fitness < pbest_values[i]:
                pbest_values[i] = fitness
                pbest_positions[i] = particles[i].copy()

        # Update global best
        gbest_index = np.argmin(pbest_values)
        if pbest_values[gbest_index] < gbest_value:
            gbest_value = pbest_values[gbest_index]
            gbest_position = pbest_positions[gbest_index].copy()

        # Update velocity and position
        for i in range(num_particles):
            r1, r2 = np.random.rand(2)
            velocities[i] = (
                W * velocities[i] +
                C1 * r1 * (pbest_positions[i] - particles[i]) +
                C2 * r2 * (gbest_position - particles[i])
            )
            particles[i] = particles[i] + velocities[i]

        # Print progress
        print(f"Iteration {iteration+1}: Best Value = {gbest_value:.6f} at {gbest_position}")

    return gbest_position, gbest_value

# Run PSO for 5 iterations
best_position, best_value = PSO()
print("\nFinal Best Position:", best_position)
print("Final Best Value:", best_value)
