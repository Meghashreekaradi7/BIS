  import random

# ----------- Fitness Function -----------
# Goal: find flattest upward U-shape y = ax^2 + bx + c
def fitness(ind):
    a, b, c = ind
    if a <= 0: return -9999       # punish downward parabolas
    vx = -b / (2*a)               # vertex x
    vy = a*vx*vx + b*vx + c       # vertex y
    y_left = a*(-1)**2 + b*(-1) + c
    y_right = a*(1)**2 + b*(1) + c
    return -(abs(y_left - vy) + abs(y_right - vy))  # flatter is better

# ----------- Initialize Population -----------
def create_population(size):
    return [[random.uniform(-5,5) for _ in range(3)] for _ in range(size)]

# ----------- Selection (pick best half) -----------
def select(pop):
    return sorted(pop, key=fitness, reverse=True)[:len(pop)//2]

# ----------- Crossover -----------
def crossover(p1, p2):
    return [(p1[i]+p2[i])/2 for i in range(3)]

# ----------- Mutation -----------
def mutate(ind, rate=0.2):
    return [x + random.uniform(-1,1) if random.random()<rate else x for x in ind]

# ----------- Main GA Loop -----------
pop = create_population(10)
for gen in range(10):   # 10 generations
    pop = select(pop)   # selection
    new_pop = []
    while len(new_pop) < 10:
        p1, p2 = random.sample(pop, 2)
        child = crossover(p1, p2)
        child = mutate(child)
        new_pop.append(child)
    pop = new_pop
    best = max(pop, key=fitness)
    print(f"Gen {gen+1}: a={best[0]:.2f}, b={best[1]:.2f}, c={best[2]:.2f}, fitness={fitness(best):.2f}")

# ----------- Final Result -----------
best = max(pop, key=fitness)
print("\nBest solution found:")
print(f"a={best[0]:.2f}, b={best[1]:.2f}, c={best[2]:.2f}, fitness={fitness(best):.2f}")


On Mon, Aug 25, 2025 at 11:47â€¯AM Meghashree Siddappa Karadi <meghashree.cs23@bmsce.ac.in> wrote:
import random

# ----------- Fitness Function -----------
# Goal: find flattest upward U-shape y = ax^2 + bx + c
def fitness(ind):
    a, b, c = ind
    if a <= 0: return -9999       # punish downward parabolas
    vx = -b / (2*a)               # vertex x
    vy = a*vx*vx + b*vx + c       # vertex y
    y_left = a*(-1)**2 + b*(-1) + c
    y_right = a*(1)**2 + b*(1) + c
    return -(abs(y_left - vy) + abs(y_right - vy))  # flatter is better

# ----------- Initialize Population -----------
def create_population(size):
    return [[random.uniform(-5,5) for _ in range(3)] for _ in range(size)]

# ----------- Selection (pick best half) -----------
def select(pop):
    return sorted(pop, key=fitness, reverse=True)[:len(pop)//2]

# ----------- Crossover -----------
def crossover(p1, p2):
    return [(p1[i]+p2[i])/2 for i in range(3)]

# ----------- Mutation -----------
def mutate(ind, rate=0.2):
    return [x + random.uniform(-1,1) if random.random()<rate else x for x in ind]

# ----------- Main GA Loop -----------
pop = create_population(10)
for gen in range(10):   # 10 generations
    pop = select(pop)   # selection
    new_pop = []
    while len(new_pop) < 10:
        p1, p2 = random.sample(pop, 2)
        child = crossover(p1, p2)
        child = mutate(child)
        new_pop.append(child)
    pop = new_pop
    best = max(pop, key=fitness)
    print(f"Gen {gen+1}: a={best[0]:.2f}, b={best[1]:.2f}, c={best[2]:.2f}, fitness={fitness(best):.2f}")

# ----------- Final Result -----------
best = max(pop, key=fitness)
print("\nBest solution found:")
print(f"a={best[0]:.2f}, b={best[1]:.2f}, c={best[2]:.2f}, fitness={fitness(best):.2f}")
